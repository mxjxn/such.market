<!-- generated by @neynar/create-farcaster-mini-app version 1.2.28 -->

# Such.Market ðŸŽ¨

A Farcaster Mini App for exploring and discovering NFT collections on Base. Built with Next.js, TypeScript, and Supabase with advanced caching and optimized database architecture.

## Features

- **Browse NFT collections** on Base with real-time updates
- **View detailed NFT metadata** and traits with efficient filtering
- **Advanced caching system** with 95%+ hit rate and <100ms response times
- **Event-driven cache invalidation** for automatic data consistency
- **Real-time performance monitoring** and analytics dashboard
- **Farcaster Frame integration** for sharing NFTs
- **Mobile-first design** optimized for Farcaster's single-column layout

## Tech Stack

- **Frontend**: Next.js 14, React, TypeScript, Tailwind CSS
- **Backend**: Next.js API Routes with advanced caching
- **Database**: Supabase (PostgreSQL) with normalized schema
- **Caching**: Upstash Redis with hierarchical cache strategy
- **Blockchain**: Base, Alchemy SDK
- **Authentication**: Farcaster (via Neynar)
- **Performance**: Event-driven cache invalidation, real-time analytics

## Documentation ðŸ“š

### ðŸ“Š Database & Performance
- **[Database Optimization Analysis](docs/database-optimization-analysis.md)** - Complete 3-phase optimization with event-driven caching, analytics, and performance testing
- **[API Endpoints Cheatsheet](docs/api-endpoints-cheatsheet.md)** - Comprehensive guide to all API endpoints with examples and troubleshooting

### ðŸŽ¯ Farcaster Integration
- **[FC Collection System](docs/fc-collection-system.md)** - Farcaster-focused collection loading and community features

### ðŸš€ Getting Started
- **[Quick Start Guide](#getting-started)** - Setup and deployment instructions
- **[Environment Configuration](#environment-setup)** - Required API keys and configuration

## Recent Optimizations âœ…

### Phase 1: Redis Configuration
- Unified Redis environment variables
- Hierarchical cache strategy (hot/warm/cold data)
- Cache warming and intelligent management

### Phase 2: Database Schema
- Normalized ownership tracking with dedicated tables
- Automatic data consistency through PostgreSQL triggers
- 3-5x faster database queries with proper indexing

### Phase 3: Advanced Caching
- **Event-driven cache invalidation** with automatic management
- **Real-time cache analytics** with performance monitoring
- **Comprehensive performance testing** framework
- **95%+ cache hit rate** with <100ms response times

## Getting Started

### Prerequisites

- Node.js 18+ and pnpm
- A Supabase account (via Vercel)
- An Alchemy API key
- A Neynar API key
- An Upstash Redis account

### Environment Setup

1. Clone the repository:
```bash
git clone git@github.com:mxjxn/such.market.git
cd such.market
```

2. Install dependencies:
```bash
pnpm install
```

3. Create a `.env.local` file with the following variables:
```env
# Supabase
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key  # For client-side access
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key  # For server-side admin access

# Redis (Required for advanced caching)
KV_REST_API_URL=your_redis_url
KV_REST_API_TOKEN=your_redis_token

# Alchemy
ALCHEMY_API_KEY=your_alchemy_api_key

# Neynar
NEXT_PUBLIC_NEYNAR_API_KEY=your_neynar_api_key
```

### Development

1. Start the development server:
```bash
pnpm dev
```

2. Run database migrations:
```bash
pnpm db:migrate
```

3. Seed the database (if needed):
```bash
pnpm db:seed
```

4. Monitor cache performance:
```bash
# Check cache metrics
curl "http://localhost:3000/api/admin/cache/metrics"

# Run performance tests
curl -X POST "http://localhost:3000/api/admin/cache/test/performance" \
  -H "Content-Type: application/json" \
  -d '{"action": "run"}'
```

## Database Structure

The application uses Supabase (PostgreSQL) with an optimized normalized schema:

- `collections`: NFT collection metadata
- `nfts`: Individual NFT data with ownership tracking
- `nft_ownership`: Normalized ownership records
- `user_collections`: Auto-maintained user collection summaries
- `wallet_collection_mapping`: Wallet-to-collection relationships
- `collection_traits`: Trait data for efficient filtering

See `db/migrations/` for the complete schema and optimization details in the [Database Optimization Analysis](docs/database-optimization-analysis.md).

## Performance Monitoring

### Cache Analytics Dashboard
- Real-time cache hit rates and response times
- Endpoint-specific performance metrics
- Automated alerts for performance issues
- Event queue monitoring

### Performance Testing
- Comprehensive test suite for cache operations
- Load testing with concurrent user simulation
- Stress testing with breaking point detection
- Performance recommendations and optimization

## Deployment

The application is configured for deployment on Vercel:

1. Connect your GitHub repository to Vercel
2. Add the required environment variables
3. Deploy!

Vercel will automatically:
- Build the Next.js application
- Run database migrations
- Set up the Supabase integration
- Configure Redis caching

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- [Neynar](https://neynar.com/) for Farcaster integration
- [Alchemy](https://www.alchemy.com/) for blockchain data
- [Supabase](https://supabase.com/) for database
- [Upstash](https://upstash.com/) for Redis
- [Base](https://base.org/) for the blockchain
- [Seaport](https://github.com/ProjectOpenSea/seaport) for NFT trading infrastructure
